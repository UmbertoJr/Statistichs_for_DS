alpha=vector['alpha']
beta =vector['beta']
gamma =vector['gamma']
tau.square = vector['tau.square']
cat(alpha,beta, gamma, tau.square)
mu = (alpha-beta* (gamma^(xi)))
resul  <- rnorm(n = 1, mean = mu, sd = sqrt(tau.square))
return(resul)
}
likel <- Vectorize(likel)
likel(start,20)
x <- c(1,2,3,4)
x[1]
x[2]
x[3]
x <- c(1,2,9,4)
x[3]
x(3)
start[1]
start[2]
start[3]
start[4]
caz <- start[1]
caz
likel <- function(vector,xi){
alpha=vector[1]
beta =vector[2]
gamma =vector[3]
tau.square = vector[4]
cat(alpha,beta, gamma, tau.square)
mu = (alpha - beta*(gamma^(xi)))
resul  <- rnorm(n = 1, mean = mu, sd = sqrt(tau.square))
return(resul)
}
likel <- Vectorize(likel)
likel(start,20)
likel <- function(vector,xi){
alpha=vector[1]
beta =vector[2]
gamma =vector[3]
tau.square = vector[4]
cat(alpha,beta, gamma, tau.square)
mu = (alpha - beta*(gamma^(xi)))
resul  <- rnorm(n = 1, mean = mu, sd = sqrt(tau.square))
return(alpha)
}
likel <- Vectorize(likel)
likel(start,20)
likel <- function(vector,xi){
alpha.hat=vector[1]
beta.hat =vector[2]
gamma.hat =vector[3]
tau.square.hat = vector[4]
mu.hat = (alpha.hat - beta.hat*(gamma.hat^(xi)))
resul  <- rnorm(n = 1, mean = mu.hat, sd = sqrt(tau.square.hat))
return(resul)
}
likel(start,20)
posterior_predictive_20 <- likel(t(simulation1),20)
hist(posterior_predictive_20)
posterior_predictive_20
likel <- Vectorize(likel)
posterior_predictive_20 <- likel(t(simulation1),20)
posterior_predictive_20 <- likel(simulation1,20)
likel(start,20)
likel <- function(vector,xi){
alpha.hat=vector[1]
beta.hat =vector[2]
gamma.hat =vector[3]
tau.square.hat = vector[4]
mu.hat = (alpha.hat - beta.hat*(gamma.hat^(xi)))
resul  <- rnorm(n = 1, mean = mu.hat, sd = sqrt(tau.square.hat))
return(resul)
}
likel(start,20)
rep
?rep
posterior_predictive_20 <- rep(NA,length(simulation2))
for(i in 1:length(simulation1)){
posterior_predictive_20[i] <- likel(simulation1[i],20)
}
likel(simulation1[1],20)
simulation1
simulation1[1]
simulation1[1,]
posterior_predictive_20 <- rep(NA,length(simulation2))
for(i in 1:length(simulation1)){
posterior_predictive_20[i] <- likel(simulation1[i,],20)
}
simulation1[1,]
likel(simulation1[1,],20)
likel(simulation1[1,],20)
length(simulation1)
likel(simulation1[4000,],20)
posterior_predictive_20 <- rep(NA,length(simulation2))
for(i in 1:length(simulation1)){
posterior_predictive_20[i] <- likel(simulation1[i,],20)
}
posterior_predictive_20 <- rep(NA,length(simulation2))
for(ind in 1:length(simulation1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
length(posterior_predictive_20)
posterior_predictive_20 <- rep(NA,length(simulation2))
for(ind in 1:length(simulation1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:length(simulation1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
likel(simulation1[4000,],20)
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:length(simulation1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:(length(simulation1)-1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:(length(simulation1)-1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
likel <- Vectorize(likel)
likel(simulation1,20)
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:(length(simulation1)-1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
dat_sim <- data.frame(simulation1)
likel(dat_sim[4000,],20)
likel(dat_sim[4000],20)
likel(dat_sim[4000,],20)
dat_sim[4000,]
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:(length(simulation1)-1)){
cat(ind, '\n')
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
posterior_predictive_20 <- rep(NA,length(simulation1))
for(ind in 1:(length(simulation1)-1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
posterior_predictive_20 <- matrix(nrow = length(simulation1))
for(ind in 1:(length(simulation1)-1)){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
likel <- function(vector,xi){
alpha.hat=vector[1]
beta.hat =vector[2]
gamma.hat =vector[3]
tau.square.hat = vector[4]
mu.hat = (alpha.hat - beta.hat*(gamma.hat^(xi)))
resul  <- rnorm(n = 1, mean = mu.hat, sd = sqrt(tau.square.hat))
return(resul)
}
likel(simulation1[2,],20)
likel <- function(vector,xi){
alpha.hat=vector[1]
beta.hat =vector[2]
gamma.hat =vector[3]
tau.square.hat = vector[4]
mu.hat = (alpha.hat - beta.hat*(gamma.hat^(xi)))
resul  <- rnorm(n = 1, mean = mu.hat, sd = sqrt(tau.square.hat))
return(resul)
}
likel(simulation1[2,],20)
simulation1
dim(simulation1)
simulation1[2,]
dim(simulation1)[1]
posterior_predictive_20 <- matrix(nrow = dim(simulation1)[1])
for(ind in 1:(dim(simulation1)[1])){
posterior_predictive_20[ind] <- likel(simulation1[ind,],20)
}
posterior_predictive_20
hist(posterior_predictive_20)
knitr::opts_chunk$set(echo = TRUE, out.width='300px', dpi=200, fig.height = 4)
c("mean estimator for alpha" = mean(simulation1[,1])  ,"standard error"= mcmcse::mcse(simulation1[,1])$se)
library(knitr)
kable(c("mean estimator for alpha" = mean(simulation1[,1])  ,"standard error"= mcmcse::mcse(simulation1[,1])$se), caption = "A knitr table")
kable(data.frame(c("mean estimator for alpha" = mean(simulation1[,1])  ,"standard error"= mcmcse::mcse(simulation1[,1])$se)), caption = "A knitr table")
library(knitr)
kable(data.frame(c("mean estimator for alpha" = mean(simulation1[,1])  ,"standard error"= mcmcse::mcse(simulation1[,1])$se)), caption = "A knitr table")
library(knitr)
kable(data.frame(c("mean estimator for alpha" = mean(simulation1[,1])  ,"standard error"= mcmcse::mcse(simulation1[,1])$se)), format = 'markdown')
data.frame(c("mean estimator for alpha" = mean(simulation1[,1]),"standard error"= mcmcse::mcse(simulation1[,1])$se))
data.frame(c("mean estimator for alpha" = mean(simulation1[,1]),"standard error"= mcmcse::mcse(simulation1[,1])$se),header =0)
data.frame(c("mean estimator for alpha" = mean(simulation1[,1]),"standard error"= mcmcse::mcse(simulation1[,1])$se))
c("mean estimator for alpha" = mean(simulation1[,1]),"standard error"= mcmcse::mcse(simulation1[,1])$se)
??knitr
dtarget<- function(x) dnorm(x)
dauxiliary <- function(x) dcauchy(x)
rauxiliary <- function(n) rcauchy(n)
samp = rauxiliary(1e+5)
M = max((dtarget(samp)/dauxiliary(samp)))
k= mean((dtarget(samp)/dauxiliary(samp)))
M
k
1/k
M = M*(1.0001)
AR=function(dtarget,dauxiliary,rauxiliary,M){
count=0
E=0
while(E==0){
candidate = rauxiliary(1)
acc_prob= (dtarget(candidate)/(M*dauxiliary(candidate)))
E = sample(c(1,0),prob=c(acc_prob, 1-acc_prob),size=1)
count=count+1
}
return(list(draw=candidate,computational_effort=count))
}
curve(dauxiliary(x)*M, col ='blue', from = -10, to = 10)
curve(dtarget, col= 'red',add=T)
mcsize=1000
draw_vec=rep(NA,mcsize)
effort_vec=rep(NA,mcsize)
for(i in 1:mcsize){
DD=AR(dtarget,dauxiliary,rauxiliary,M)
draw_vec[i] = DD$draw
effort_vec[i] = DD$computational_effort
}
hist(draw_vec,freq=FALSE)
curve(dtarget(x),add=TRUE)
plot(prop.table(table(effort_vec)),ylim=c(0,1),pch=16,col="red")
mcsize=1000
draw_vec=rep(NA,mcsize)
effort_vec=rep(NA,mcsize)
for(i in 1:mcsize){
DD=AR(dtarget,dauxiliary,rauxiliary,M)
draw_vec[i] = DD$draw
effort_vec[i] = DD$computational_effort
}
hist(draw_vec,freq=FALSE)
curve(dtarget(x),add=TRUE)
plot(prop.table(table(effort_vec)),ylim=c(0,1),pch=16,col="red")
c("M is" = M , "and P(E=1)"= 1/M)
c("M " = M , "    P(E=1)"= 1/M)
S=c(1,2)        # discrete state space
alpha<-0.2      # set up the TPM (Transition Probability Matrix)
beta<-0.5
tpm<-matrix(c(1-alpha,alpha,beta,1-beta),nrow=2,byrow=T)
tpm
x1<-2 ## starting value of the chain
## [from a degenerate distribution with mass 1 at state s=2]
nsample<-10
chain<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
chain[1]<-x1             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(S,size=1,prob=tpm[chain[t],])
}
S
plot(chain,ylim=c(0,4))
plot(chain,ylim=c(0,4),type="b")
table(chain)
mean(chain)
nsample<-10000 #  length of the initial part of the sample path
#  of our Markov chain (stochastic process)
chain<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
# Let us start from x1=1
x1=1
chain[1]<-x1             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(S,size=1,prob=tpm[chain[t],])
}
mean(chain)       # our first example of empirical mean [h(x)=x]
mean(chain==2)    # our second example of empirical mean [h(x)=I_{1}(x)]
table(chain)
prop.table(table(chain))
x1=2
chain[1]<-x1             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(S,size=1,prob=tpm[chain[t],])
}
mean(chain)       # our first example of empirical mean [h(x)=x]
mean(chain==2)    # our second example of empirical mean [h(x)=I_{1}(x)]
table(chain)
prop.table(table(chain))
runningmeans=cumsum(chain)/(1:length(chain))
plot(1:length(chain),runningmeans)
title(main="stabilization of the running means")
runningmeans[length(runningmeans)]
state=1
runningmeans=cumsum(chain==state)/(1:length(chain))
plot(1:length(chain),runningmeans)
title(main="stabilization of the running relative frequencies \n of occurrence of state 1")
runningmeans[length(runningmeans)]
tpm
tpm%*%tpm
tpm%*%tpm%*%tpm
tpm%*%tpm%*%tpm%*%tpm
tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm
# ...
tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm
tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm%*%tpm
??markovchain
library(markovchain)
states <- c('1','2','3')
ByRow <- TRUE
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = ByRow,nrow=3)
Mc_states <- new('markovchain', states = states, byrow = ByRow, transitionMatrix = transition_matrix, name='Position')
initial_state <- c(1,0,0)
plot(Mc_states)
states <- c('1','2','3')
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = TRUE ,nrow=3)
x1 <- 1
nsample<-1000
chain<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
chain[1]<-x1             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
x1 <- 1
nsample<-1000
chain<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
chain[1]<-x1             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = TRUE ,nrow=3)
transition_matrix
transition_matrix[1]
transition_matrix[1,]
transition_matrix[chain[t],]
chain
chain[2]
states <- c(1,2,3)
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = TRUE ,nrow=3)
x1 <- 1
nsample<-1000
chain<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
chain[1]<-x1             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
plot(chain,ylim=c(0,4))
plot(chain,ylim=c(0,4),type="b")
table(chain)
t0 <- 1
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain[1]<-t0             # starting value x1 assigned to chain[1]
chain<-rep(NA,nsample+1) # vector that will hold
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
t1000[i]<- chain[nsample+1]
}
states <- c(1,2,3)
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = TRUE ,nrow=3)
t0 <- 1
nsample<-1000
chain<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
chain[1]<-t0             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
prop.table(table(chain))
t0 <- 1
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain[1]<-t0             # starting value x1 assigned to chain[1]
chain<-rep(NA,nsample+1) # vector that will hold
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
t1000[i]<- chain[nsample+1]
}
t0 <- 1
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain[1]<-t0             # starting value x1 assigned to chain[1]
chain<-rep(NA,nsample+1) # vector that will hold
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
t1000[i]<- chain[nsample+1]
}
t0 <- 1
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain<-rep(NA,nsample+1) # vector that will hold
chain[1]<-t0             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
t1000[i]<- chain[nsample+1]
}
t1000
prop.table(table(t1000))
t0 <- 1
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain<-rep(NA,nsample+1) # vector that will hold
chain[1]<-t0             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain[t+1]<-sample(states,size=1,prob=transition_matrix[chain[t],])
}
t1000[i]<- chain[nsample+1]
}
prop.table(table(t1000))
eigen(transition_matrix)
eigen(transition_matrix)$vector[1]
eigen(transition_matrix)$vector[1,]
sum(eigen(transition_matrix)$vector[1,])
sum(eigen(transition_matrix)$vector[,1])
eigen(transition_matrix)
library(markovchain)
states <- c(1,2,3)
ByRow <- TRUE
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = ByRow,nrow=3)
Mc_states <- new('markovchain', states = states, byrow = ByRow, transitionMatrix = transition_matrix, name='Position')
initial_state <- c(1,0,0)
pi <- Mc_states^1000
pi
eigen(transition_matrix)$vectors[1,]%*%transition_matrix
eigen(transition_matrix)$vectors[1,]%*%transition_matrix
eigen(transition_matrix)$vectors[1,]
eigen(transition_matrix)$vectors[2,]%*%transition_matrix
eigen(transition_matrix)$vectors[2,]
eigen(transition_matrix)$vectors[3,]%*%transition_matrix
eigen(transition_matrix)$vectors[3,]
eigen(transition_matrix)$vectors[,1]%*%transition_matrix
eigen(transition_matrix)$vectors[,1]
eigen(transition_matrix)$vectors[,2]%*%transition_matrix
eigen(transition_matrix)$vectors[,2]
eigen(transition_matrix)$vectors[,3]%*%transition_matrix
eigen(transition_matrix)$vectors[,3]
library(markovchain)
states <- c(1,2,3)
ByRow <- TRUE
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = ByRow,nrow=3)
Mc_states <- new('markovchain', states = states, byrow = ByRow, transitionMatrix = transition_matrix, name='Position')
library(markovchain)
states <- c('1','2','3')
ByRow <- TRUE
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = ByRow,nrow=3)
Mc_states <- new('markovchain', states = states, byrow = ByRow, transitionMatrix = transition_matrix, name='Position')
pi <- Mc_states^1000
Mc_states^1000
Mc_states^1000[1,]
(Mc_states^1000)[1,]
states <- c(1,2,3)
transition_matrix <- matrix(data= c(0,1/2,1/2,
5/8,1/8,1/4,
2/3,1/3,0), byrow = TRUE ,nrow=3)
t0 <- 2
nsample<-1000
chain1<-rep(NA,nsample+1) # vector that will hold
# all the simulated values
chain1[1]<-t0             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain1[t+1]<-sample(states,size=1,prob=transition_matrix[chain1[t],])
}
prop.table(table(chain))
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain2<-rep(NA,nsample+1) # vector that will hold
chain2[1]<-t0             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain2[t+1]<-sample(states,size=1,prob=transition_matrix[chain2[t],])
}
t1000[i]<- chain2[nsample+1]
}
prop.table(table(t1000))
ntimes <- 500
nsample<-1000
t1000 <-rep(NA,ntimes)
for(i in 1:ntimes){
chain2<-rep(NA,nsample+1) # vector that will hold
chain2[1]<-t0             # starting value x1 assigned to chain[1]
for(t in 1:nsample){
chain2[t+1]<-sample(states,size=1,prob=transition_matrix[chain2[t],])
}
t1000[i]<- chain2[nsample+1]
}
prop.table(table(t1000))
